<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TETRIS üß± Retro</title>

<style>
body {
    background: linear-gradient(#c0c0ff, #e0e0ff);
    font-family: Tahoma, Verdana, "Comic Sans MS", sans-serif;
    margin: 0;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.container {
    background: #f0f0f0;
    border: 4px solid #333;
    padding: 15px;
    text-align: center;
}

h1 {
    color: #00008b;
    text-shadow: 1px 1px white;
}

.game-frame {
    position: relative;
    border: 4px solid #333;
    background: black;
    display: inline-block;
}

canvas {
    background: black;
}

#countdown, #gameOverMsg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 42px;
    font-weight: bold;
    color: red;
    text-shadow: 2px 2px black;
}

#gameOverMsg { display: none; }

#score { font-weight: bold; margin-top: 8px; }

button {
    margin-top: 10px;
    padding: 6px 14px;
    font-weight: bold;
    border: 2px outset #666;
    cursor: pointer;
}
</style>
</head>

<body>

<div class="container">
    <h1>TETRIS</h1>

    <div class="game-frame">
        <canvas id="tetris" width="200" height="400"></canvas>
        <div id="countdown"></div>
        <div id="gameOverMsg">GAME OVER</div>
    </div>

    <div id="score">Score: 0</div>
    <button id="restartBtn" style="display:none;">Restart</button>
    <button onclick="location.href='index.html'">Back</button>
    <p>‚Üê ‚Üí move ¬∑ ‚Üë rotate ¬∑ ‚Üì drop</p>
</div>

<script>
/* ===== SETUP ===== */
const canvas = document.getElementById("tetris");
const ctx = canvas.getContext("2d");
const block = 20;

const arena = Array.from({ length: 20 }, () => Array(10).fill(0));
const colors = [null,"#0f0","#f00","#00f","#ff0","#f0f","#0ff","#fa0"];

const player = {
    pos: { x: 0, y: 0 },
    matrix: null,
    score: 0
};

let dropCounter = 0;
let dropInterval = 800;
let lastTime = 0;
let animationId;
let gameOver = false;

const scoreEl = document.getElementById("score");
const gameOverMsg = document.getElementById("gameOverMsg");
const restartBtn = document.getElementById("restartBtn");
const countdownEl = document.getElementById("countdown");

/* ===== PIECES ===== */
function createPiece(t) {
    if (t === "T") return [[0,1,0],[1,1,1]];
    if (t === "O") return [[2,2],[2,2]];
    if (t === "L") return [[0,0,3],[3,3,3]];
    if (t === "J") return [[4,0,0],[4,4,4]];
    if (t === "I") return [[5],[5],[5],[5]];
    if (t === "S") return [[0,6,6],[6,6,0]];
    if (t === "Z") return [[7,7,0],[0,7,7]];
}

/* ===== COLLISION ===== */
function collide() {
    for (let y = 0; y < player.matrix.length; y++) {
        for (let x = 0; x < player.matrix[y].length; x++) {
            if (player.matrix[y][x]) {
                const ny = y + player.pos.y;
                const nx = x + player.pos.x;

                if (
                    nx < 0 ||
                    nx >= 10 ||
                    ny >= 20 ||
                    arena[ny]?.[nx]
                ) return true;
            }
        }
    }
    return false;
}

/* ===== RESET ===== */
function playerReset() {
    const pieces = "TJLOSZI";
    player.matrix = createPiece(pieces[Math.random() * pieces.length | 0]);
    player.pos.y = 0;
    player.pos.x = 3;

    if (collide()) {
        gameOver = true;
        cancelAnimationFrame(animationId);
        gameOverMsg.style.display = "block";
        restartBtn.style.display = "inline-block";
    }
}

/* ===== MERGE ===== */
function merge() {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value) arena[y + player.pos.y][x + player.pos.x] = value;
        });
    });
}

/* ===== FIX DEFINITIVO: CLEAR LINES ===== */
function arenaSweep() {
    let linesCleared = 0;

    for (let y = arena.length - 1; y >= 0; ) {
        if (arena[y].every(cell => cell !== 0)) {
            arena.splice(y, 1);
            arena.unshift(Array(10).fill(0));
            linesCleared++;
        } else {
            y--; // üëà CLAVE: solo bajamos si no borramos
        }
    }

    if (linesCleared > 0) {
        player.score += linesCleared * 10;

        // bonus tipo Tetris real
        if (linesCleared === 4) {
            player.score += 20; // TETRIS üî•
        }

        dropInterval = Math.max(200, dropInterval - linesCleared * 40);
    }
}

/* ===== DRAW ===== */
function drawBlock(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * block, y * block, block, block);
    ctx.strokeStyle = "#000";
    ctx.strokeRect(x * block, y * block, block, block);
}

function draw() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    arena.forEach((row, y) =>
        row.forEach((v, x) => v && drawBlock(x, y, colors[v]))
    );

    player.matrix.forEach((row, y) =>
        row.forEach((v, x) => v && drawBlock(x + player.pos.x, y + player.pos.y, colors[v]))
    );
}

/* ===== LOOP ===== */
function update(time = 0) {
    if (gameOver) return;

    const delta = time - lastTime;
    lastTime = time;
    dropCounter += delta;

    if (dropCounter > dropInterval) {
        player.pos.y++;
        if (collide()) {
            player.pos.y--;
            merge();
            arenaSweep();
            updateScore();
            playerReset();
        }
        dropCounter = 0;
    }

    draw();
    animationId = requestAnimationFrame(update);
}

/* ===== SCORE ===== */
function updateScore() {
    scoreEl.textContent = "Score: " + player.score;
}

/* ===== ROTATE SAFE ===== */
function rotate() {
    const prev = player.matrix;
    player.matrix = prev[0].map((_, i) => prev.map(row => row[i]).reverse());
    if (collide()) player.matrix = prev;
}

/* ===== CONTROLS ===== */
document.addEventListener("keydown", e => {
    if (gameOver) return;

    const prevX = player.pos.x;

    if (e.key === "ArrowLeft") player.pos.x--;
    if (e.key === "ArrowRight") player.pos.x++;
    if (e.key === "ArrowDown") {
        player.pos.y++;
        if (collide()) {
            player.pos.y--;
            merge();
            arenaSweep();
            updateScore();
            playerReset();
        }
    }
    if (e.key === "ArrowUp") rotate();

    if (collide()) player.pos.x = prevX;
});

/* ===== RESTART ===== */
restartBtn.onclick = () => {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    dropInterval = 800;
    gameOver = false;

    gameOverMsg.style.display = "none";
    restartBtn.style.display = "none";

    updateScore();
    playerReset();
    update();
};

/* ===== COUNTDOWN ===== */
let c = 3;
countdownEl.textContent = c;

const timer = setInterval(() => {
    c--;
    if (c > 0) countdownEl.textContent = c;
    else {
        clearInterval(timer);
        countdownEl.textContent = "";
        playerReset();
        updateScore();
        update();
    }
}, 1000);
</script>

</body>
</html>


